<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rizz System â€” Phase A (Version 1)</title>
<style>
  :root{
    --bg:#000; --card:#0f1112; --muted:#9aa3ad; --accent:#00d08a;
    --btn:#e9f1f8; --danger:#ff8a8a; --info:#ffb020;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  .wrap{max-width:760px;margin:0 auto;padding:20px;}
  h1{font-size:34px;margin:4px 0 18px;line-height:1.05}
  .controls{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:18px}
  .input{flex:1;min-width:200px;padding:14px;border-radius:14px;border:0;background:#fff;color:#222}
  .btn{padding:10px 14px;border-radius:12px;background:var(--btn);color:#0b66d1;border:0;cursor:pointer}
  .btn-dark{background:#1b1c1d;color:#9fb8ff}
  .card{background:var(--card);padding:18px;border-radius:16px;margin:12px 0}
  .row{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  .person-title{font-weight:700;font-size:20px}
  .badge{padding:6px 10px;border-radius:10px;background:var(--accent);color:#00261a;font-weight:700}
  .small-badge{padding:6px 10px;border-radius:10px;background:#2b2d2e;color:#cbd3d9}
  .progress-wrap{margin:10px 0}
  .progress{height:12px;background:#232425;border-radius:8px;overflow:hidden}
  .progress > .bar{height:100%;background:linear-gradient(90deg,var(--accent),#20c98f);transition:width .3s}
  .controls-row{display:flex;gap:12px;flex-wrap:wrap;margin-top:10px}
  .action{padding:10px 14px;border-radius:14px;background:#0f1720;color:#9fb8ff;border:0;cursor:pointer}
  .danger{background:var(--danger);color:#400}
  .thumb{max-width:80px;max-height:120px;border-radius:8px;display:block;margin-top:12px}
  .note{color:var(--muted);margin-top:12px}
  .alert{background:var(--info);color:#1a0b00;padding:12px;border-radius:12px;margin-bottom:12px}
  .prediction{margin-top:12px;color:#cbd3d9}
  footer{color:var(--muted);margin-top:20px}
  @media(min-width:720px){h1{font-size:44px}}
</style>
</head>
<body>
  <div class="wrap">
    <h1>ðŸ”¥ Rizz System â€” Version 1 (Phase A)</h1>

    <div class="controls">
      <input id="nameInput" class="input" placeholder="Add name (e.g. Charity)" />
      <button id="addBtn" class="btn">Add / Update</button>
      <button id="decayBtn" class="btn btn-dark">Run Decay (test)</button>
    </div>

    <div id="alertBox" style="display:none" class="alert"></div>

    <div id="peopleContainer"></div>

    <div class="note">
      Tip: +10 / -10 clamps to 0..100. Focus limit = <span id="focusLimitLabel">2</span>. Auto-focus at â‰¥90%. Decay reduces score by 10 every 2 days automatically on load (localStorage).
    </div>
    <footer>Saved locally in your browser (localStorage). Thumbnails stored as base64 in localStorage (small images recommended).</footer>
  </div>

<script>
/* ---------- CONFIG ---------- */
const FOCUS_LIMIT = 2;
const AUTO_FOCUS_THRESHOLD = 90;
const DECAY_INTERVAL_DAYS = 2;  // apply each DECAY_STEP every 2 days
const DECAY_STEP = 10;
const STORAGE_KEY = 'rizz_v1_data';
/* ---------- /CONFIG ---------- */

document.getElementById('focusLimitLabel').innerText = FOCUS_LIMIT;

const nameInput = document.getElementById('nameInput');
const addBtn = document.getElementById('addBtn');
const decayBtn = document.getElementById('decayBtn');
const peopleContainer = document.getElementById('peopleContainer');
const alertBox = document.getElementById('alertBox');

let state = { people: [], lastDecayAt: null };

/* safe load */
function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const parsed = JSON.parse(raw);
      if(parsed && Array.isArray(parsed.people)) state = parsed;
      else state = { people: [], lastDecayAt: null };
    } else {
      state = { people: [], lastDecayAt: null };
      saveState();
    }
  }catch(e){
    console.warn('loadState error', e);
    state = { people: [], lastDecayAt: null };
  }
}

/* safe save */
function saveState(){
  try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
  catch(e){ console.error('saveState error', e); }
}

/* helpers */
function uid(){ return 'p' + Date.now().toString(36) + Math.random().toString(36).slice(2,6); }
function clamp(n){ return Math.max(0, Math.min(100, Math.round(n))); }
function nowISO(){ return new Date().toISOString(); }
function nowMs(){ return Date.now(); }
function showAlert(msg, ms=2000){
  alertBox.style.display='block'; alertBox.textContent = msg;
  setTimeout(()=>{ alertBox.style.display='none'; }, ms);
}

/* add/update */
function addOrUpdatePerson(name){
  name = String(name||'').trim();
  if(!name){ showAlert('Please enter a name'); return; }
  const existing = state.people.find(p => p.name.toLowerCase() === name.toLowerCase());
  if(existing){
    existing.updatedAt = nowISO();
    showAlert(`Updated ${existing.name}`, 1200);
  } else {
    const p = {
      id: uid(),
      name,
      score: 0,
      focus: false,
      paused: false,
      thumb: null,
      createdAt: nowISO(),
      updatedAt: nowISO(),
      focusSetAt: null
    };
    state.people.push(p);
    showAlert(`Added ${p.name}`, 1200);
  }
  saveState();
  runPostChange();
}

/* delete */
function deletePerson(id){
  state.people = state.people.filter(p => p.id !== id);
  saveState();
  render();
}

/* change score */
function changeScore(id, delta){
  const p = state.people.find(x => x.id === id);
  if(!p) return;
  p.score = clamp(p.score + delta);
  p.updatedAt = nowISO();
  saveState();
  // enforce auto-focus if threshold hit
  if(p.score >= AUTO_FOCUS_THRESHOLD && !p.paused){
    enforceAutoFocusForPerson(p);
  }
  runPostChange(false);
}

/* focus (manual toggle) */
function toggleFocus(id){
  const p = state.people.find(x=> x.id === id);
  if(!p) return;
  if(p.focus){
    // unfocus
    p.focus = false;
    p.focusSetAt = null;
  } else {
    // before focusing ensure limit
    ensureFocusSpace();
    p.focus = true;
    p.focusSetAt = Date.now();
  }
  p.updatedAt = nowISO();
  saveState();
  render();
}

/* pause toggle */
function togglePause(id){
  const p = state.people.find(x=>x.id===id);
  if(!p) return;
  p.paused = !p.paused;
  // if paused while focused -> unfocus
  if(p.paused && p.focus){
    p.focus = false; p.focusSetAt = null;
  }
  p.updatedAt = nowISO();
  saveState();
  render();
}

/* attach thumbnail */
function attachThumbnail(id, file){
  const p = state.people.find(x=> x.id === id);
  if(!p || !file) return;
  const reader = new FileReader();
  reader.onload = (ev)=>{
    p.thumb = ev.target.result; // base64
    p.updatedAt = nowISO();
    saveState();
    render();
  };
  reader.readAsDataURL(file);
}

/* compute prediction (simple) */
function computePrediction(score){
  const pred = Math.round(score * 1.3);
  let label = 'Unlikely';
  if(pred >= 150) label = 'Most Likely';
  else if(pred >= 100) label = 'Possible';
  return { pred, label };
}

/* enforce focus limit by removing lowest-priority focused people until there is space
   Priority rule: remove focused with lowest score; tie-breaker remove oldest focusSetAt */
function ensureFocusSpace(){
  let focused = state.people.filter(p=>p.focus);
  while(focused.length >= FOCUS_LIMIT){
    // find the one to remove: lowest score, if tie oldest focusSetAt
    focused.sort((a,b)=>{
      if(a.score !== b.score) return a.score - b.score; // lowest first
      return (a.focusSetAt||0) - (b.focusSetAt||0);
    });
    const demote = focused.shift();
    if(demote){
      demote.focus = false;
      demote.focusSetAt = null;
      showAlert('Focus limit reached â€” removed lowest-priority focus', 1600);
    } else break;
    focused = state.people.filter(p=>p.focus);
  }
}

/* enforce auto-focus for a single person (called when their score changes) */
function enforceAutoFocusForPerson(person){
  if(person.paused) return;
  if(person.score < AUTO_FOCUS_THRESHOLD) return;
  // If already focused, nothing more
  if(person.focus) return;
  // need space
  ensureFocusSpace();
  // set focus
  person.focus = true;
  person.focusSetAt = Date.now();
  showAlert(`âš¡ Auto-Focus applied to ${person.name}`, 2000);
  saveState();
  render();
}

/* auto-focus check across all persons (load or after decay) */
function enforceAutoFocusAll(){
  // candidates: score>=threshold and not paused and not focused
  const candidates = state.people.filter(p => p.score >= AUTO_FOCUS_THRESHOLD && !p.paused && !p.focus);
  // sort deterministically: higher score first, older updated first
  candidates.sort((a,b)=> {
    if(b.score !== a.score) return b.score - a.score;
    return new Date(a.updatedAt) - new Date(b.updatedAt);
  });
  candidates.forEach(c => {
    enforceAutoFocusForPerson(c);
  });
}

/* DECAY:
   - compute how many full intervals of DECAY_INTERVAL_DAYS have passed since state.lastDecayAt
   - apply DECAY_STEP * n to each person who is NOT paused and NOT focused
   - update lastDecayAt forward by n intervals
*/
function runDecayNow(forced=false){
  const msPerInterval = DECAY_INTERVAL_DAYS * 24 * 60 * 60 * 1000;
  const now = Date.now();
  if(!state.lastDecayAt) state.lastDecayAt = new Date().toISOString();
  const lastMs = new Date(state.lastDecayAt).getTime();
  let intervals = Math.floor((now - lastMs) / msPerInterval);
  if(forced && intervals === 0) intervals = 1;
  if(intervals <= 0) {
    if(!forced) { showAlert('No full decay intervals have passed yet', 1400); return; }
  }
  let changed = false;
  state.people.forEach(p => {
    if(p.paused || p.focus) return;
    const dec = DECAY_STEP * intervals;
    if(dec > 0 && p.score > 0){
      p.score = clamp(p.score - dec);
      p.updatedAt = nowISO();
      // if drops below threshold, unfocus
      if(p.score < AUTO_FOCUS_THRESHOLD && p.focus){
        p.focus = false; p.focusSetAt = null;
      }
      changed = true;
    }
  });
  // move lastDecayAt forward by the number of intervals applied
  state.lastDecayAt = new Date(lastMs + intervals * msPerInterval).toISOString();
  if(changed) { saveState(); enforceAutoFocusAll(); render(); showAlert(`Decay applied (${intervals} step${intervals>1?'s':''})`, 1500); }
  else { saveState(); showAlert('Decay applied: nothing changed', 1200); }
}

/* action after any change */
function runPostChange(triggerDecay=true){
  if(triggerDecay) runDecayNow(false);
  enforceAutoFocusAll();
  render();
}

/* UI building & delegation */
function render(){
  peopleContainer.innerHTML = '';
  // sort: focused first, then by updatedAt desc
  const sorted = [...state.people].sort((a,b)=>{
    if(a.focus && !b.focus) return -1;
    if(!a.focus && b.focus) return 1;
    return new Date(b.updatedAt) - new Date(a.updatedAt);
  });
  if(sorted.length === 0){
    peopleContainer.innerHTML = `<div class="note">No people yet â€” add someone above.</div>`;
    return;
  }
  sorted.forEach(p => {
    const card = document.createElement('div'); card.className='card';
    const titleRow = document.createElement('div'); titleRow.className='row';
    const left = document.createElement('div'); left.innerHTML = `<div class="person-title">${escapeHtml(p.name)} â€” ${p.score}%</div>`;
    const right = document.createElement('div');
    if(p.focus) right.innerHTML = `<span class="badge">FOCUS</span>`;
    else right.innerHTML = `<span class="small-badge">${p.paused ? 'PAUSED' : 'ACTIVE'}</span>`;
    titleRow.appendChild(left); titleRow.appendChild(right); card.appendChild(titleRow);

    // progress bar
    const progWrap = document.createElement('div'); progWrap.className='progress-wrap';
    const prog = document.createElement('div'); prog.className='progress';
    const bar = document.createElement('div'); bar.className='bar'; bar.style.width = p.score + '%';
    prog.appendChild(bar); progWrap.appendChild(prog); card.appendChild(progWrap);

    // controls row
    const controls = document.createElement('div'); controls.className='controls-row';
    controls.append(elButton('-10', ()=> changeScore(p.id, -10)));
    controls.append(elButton('+10', ()=> changeScore(p.id, +10)));
    controls.append(elButton(p.focus ? 'Unfocus' : 'Focus', ()=> toggleFocus(p.id)));
    controls.append(elButton(p.paused ? 'Active' : 'Pause', ()=> togglePause(p.id)));
    controls.append(elButton('Delete', ()=> { if(confirm('Delete '+p.name+'?')) deletePerson(p.id) }, 'danger'));

    // attach thumbnail: create a hidden file input per-person and an attach button
    const fileInput = document.createElement('input'); fileInput.type='file'; fileInput.accept='image/*'; fileInput.style.display='none';
    fileInput.onchange = (ev) => {
      const f = ev.target.files && ev.target.files[0]; if(f) attachThumbnail(p.id, f);
      // clear value to allow re-upload same file later
      ev.target.value = '';
    };
    const attachBtn = elButton('Attach', ()=> fileInput.click());
    controls.appendChild(attachBtn); controls.appendChild(fileInput);

    card.appendChild(controls);

    // prediction and thumbnail
    const pred = computePrediction(p.score);
    const predDiv = document.createElement('div'); predDiv.className='prediction';
    predDiv.innerHTML = `Prediction: <strong>${pred.pred}</strong> â€” ${pred.label}`;
    card.appendChild(predDiv);

    if(p.thumb){
      const img = document.createElement('img'); img.className='thumb'; img.src = p.thumb; card.appendChild(img);
    }

    peopleContainer.appendChild(card);
  });
}

/* small helpers */
function changeScore(id, delta){
  changeScoreById(id, delta);
}
function changeScoreById(id, delta){
  const p = state.people.find(x => x.id === id);
  if(!p) return;
  p.score = clamp(p.score + delta);
  p.updatedAt = nowISO();
  saveState();
  // enforce auto-focus
  if(p.score >= AUTO_FOCUS_THRESHOLD && !p.paused) enforceAutoFocusForPerson(p);
  runPostChange(false);
}
function elButton(text, onClick, type){
  const b = document.createElement('button'); b.className='action';
  if(type === 'danger') b.classList.add('danger');
  b.innerText = text; b.onclick = onClick; return b;
}
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* expose for debugging */
window.__RIZZ = { state, saveState, loadState, runDecayNow };

/* initial load */
loadState();
/* apply pending decay intervals on load */
(function initDecayAndRender(){
  try{
    if(!state.lastDecayAt) state.lastDecayAt = new Date().toISOString();
    const now = Date.now();
    const lastMs = new Date(state.lastDecayAt).getTime();
    const msPerInterval = DECAY_INTERVAL_DAYS * 24 * 3600 * 1000;
    const intervals = Math.floor((now - lastMs) / msPerInterval);
    if(intervals > 0){
      // apply intervals
      state.people.forEach(p => {
        if(p.paused || p.focus) return;
        const dec = DECAY_STEP * intervals;
        p.score = clamp(p.score - dec);
        p.updatedAt = nowISO();
        if(p.score < AUTO_FOCUS_THRESHOLD && p.focus){ p.focus = false; p.focusSetAt = null; }
      });
      state.lastDecayAt = new Date(lastMs + intervals * msPerInterval).toISOString();
      saveState();
      showAlert(`Decay auto-run: ${intervals} step(s)`, 1200);
    }
  }catch(e){ console.warn(e) }
  // after decay, auto-focus eligible people
  enforceAutoFocusAll();
  render();
})();

/* event wiring */
addBtn.onclick = ()=>{ addOrUpdatePerson(nameInput.value); nameInput.value=''; };
decayBtn.onclick = ()=> runDecayNow(true);

</script>
</body>
</html>