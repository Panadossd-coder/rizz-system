<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rizz System â€” Version 1 (Phase A)</title>

<!-- Tesseract.js for in-browser OCR -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>

<style>
  :root{
    --bg:#050505; --card:#0f1111; --muted:#9aa0a6; --accent:#00e29a; --danger:#ff7b7b;
    --pill:#e6eefc; --btn-bg:#0b1220; --glass: rgba(255,255,255,0.04);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter, system-ui, Arial;}
  .wrap{max-width:900px;margin:18px auto;padding:0 18px;}
  h1{font-size:34px;margin:6px 0 18px}
  input[type=text]{width:100%;padding:16px;border-radius:14px;border:none;margin-bottom:10px;background:var(--card);color:#fff;font-size:16px}
  .row{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:12px}
  .btn{background:var(--pill);padding:10px 14px;border-radius:12px;border:none;color:#0b1230;font-weight:600;cursor:pointer}
  .btn-dark{background:var(--btn-bg);color:#C9D6E6}
  .info{background: #ffb300;padding:14px;border-radius:12px;color:#111;margin-bottom:14px;display:none}
  .tip{color:var(--muted);margin-top:20px}
  .card{background:var(--card);padding:18px;border-radius:16px;margin-bottom:16px;box-shadow:0 6px 18px rgba(0,0,0,0.5)}
  .title-line{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
  .progress-bar{height:12px;background:rgba(255,255,255,0.08);border-radius:12px;overflow:hidden;margin:10px 0}
  .progress{height:100%;background:linear-gradient(90deg,var(--accent),#2be4a4);width:0%}
  .badge{background:#111;padding:8px 12px;border-radius:10px;color:#cbd5df;font-weight:700}
  .focus-badge{background:#05e59b;color:#00261a;padding:8px 12px;border-radius:12px;font-weight:800}
  .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
  .control-pill{background:var(--btn-bg);color:#cfe6ff;padding:10px;border-radius:12px;cursor:pointer;min-width:64px;text-align:center}
  .danger{background:var(--danger);color:#2b0a0a}
  img.thumb{width:72px;height:96px;object-fit:cover;border-radius:8px;margin-top:12px;border:1px solid rgba(255,255,255,0.06)}
  .prediction{color:var(--muted);margin-top:10px}
  footer{margin:30px 0;color:var(--muted)}
  @media(min-width:700px){.wrap{max-width:720px}}
</style>
</head>
<body>
  <div class="wrap">
    <h1>ðŸ”¥ Rizz System â€” Version 1 (Phase A)</h1>

    <div id="alert" class="info"></div>

    <input id="nameInput" type="text" placeholder="Add name (e.g. Charity)" />
    <div class="row">
      <button id="btnAdd" class="btn">Add / Update</button>
      <button id="btnClearAll" class="btn btn-dark">Clear All</button>
      <button id="btnRunDecay" class="btn btn-dark">Run Decay (test)</button>
    </div>

    <div id="list"></div>

    <div class="tip">Tip: +10 / -10 clamps to 0..100. Focus limit = 2. Auto-focus at â‰¥90%. Decay reduces score by 10 every 2 days (applied on load and with the test button).</div>
    <footer>Saved locally in your browser (localStorage). Screenshots and OCR processed in your browser.</footer>
  </div>

<script>
/*
  Rizz System v1 (Phase A)
  - localStorage key: rizz_v1
  - focusLimit: 2
  - decayIntervalDays: 2 -> reduce 10 for each 2-day interval since lastDecay
  - autoFocusThreshold: 90
*/

const STORAGE_KEY = 'rizz_v1';
const focusLimit = 2;
const autoFocusThreshold = 90;
const decayDays = 2; // 2 days per 10 points
const decayAmount = 10;

let data = loadData();

const alertEl = document.getElementById('alert');
const listEl = document.getElementById('list');
const nameInput = document.getElementById('nameInput');
document.getElementById('btnAdd').addEventListener('click', addOrUpdatePerson);
document.getElementById('btnClearAll').addEventListener('click', clearAll);
document.getElementById('btnRunDecay').addEventListener('click', ()=>{ runDecay(true); });

/* --------- Data model helpers ---------- */
function saveData(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}

function loadData(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    const parsed = raw ? JSON.parse(raw) : {people:[], lastDecay: Date.now()};
    if(!parsed.lastDecay) parsed.lastDecay = Date.now();
    return parsed;
  }catch(e){
    return {people:[], lastDecay: Date.now()};
  }
}

function now(){return Date.now();}

function clamp(v){ return Math.max(0, Math.min(100, Math.round(v))); }

function findPerson(name){
  return data.people.find(p => p.name.toLowerCase() === name.toLowerCase());
}

/* ---------- Decay logic ---------- */
function runDecay(force=false){
  // Calculate how many decay periods passed since lastDecay
  const last = data.lastDecay || now();
  const diffDays = (now() - last) / (1000*60*60*24);
  const periods = force ? 1 : Math.floor(diffDays / decayDays);
  if(periods <= 0 && !force){
    showAlert('No decay needed yet', 2000);
    return;
  }
  if(periods > 0 || force){
    data.people.forEach(p => {
      if(p.score > 0){
        p.score = clamp(p.score - decayAmount * periods);
        p.updated = now();
        // remove focus if score drops below threshold
        if(p.score < autoFocusThreshold && p.isFocus){
          p.isFocus=false;
        }
      }
    });
    data.lastDecay = now();
    saveData();
    render();
    showAlert('Decay applied' + (force ? ' (test)' : ''), 2000);
  }
}

/* ---------- Focus / auto-focus ---------- */
function enforceFocusLimit(){
  const focused = data.people.filter(p=>p.isFocus);
  if(focused.length <= focusLimit) return;
  // remove the oldest focused (by updated time)
  focused.sort((a,b)=>a.updated - b.updated);
  while(focused.length > focusLimit){
    const rem = focused.shift();
    rem.isFocus = false;
    showAlert('Focus limit reached â€” oldest focus removed', 2500);
  }
  saveData();
  render();
}

function maybeAutoFocus(person){
  if(person.score >= autoFocusThreshold){
    if(!person.isFocus){
      person.isFocus = true;
      person.updated = now();
      // enforce limit
      enforceFocusLimit();
      saveData();
      render();
      showAlert(`${person.name} auto-focused (â‰¥ ${autoFocusThreshold}%)`, 2000);
    }
  }
}

/* ---------- UI rendering ---------- */
function render(){
  listEl.innerHTML = '';
  if(!data.people || data.people.length===0){
    listEl.innerHTML = '<div style="color:var(--muted);padding:24px">No people yet â€” add someone above.</div>';
    return;
  }
  data.people.forEach(p => listEl.appendChild(renderPersonCard(p)));
}

function renderPersonCard(p){
  const card = document.createElement('div');
  card.className = 'card';
  card.innerHTML = `
    <div class="title-line">
      <div style="font-size:20px;font-weight:700">${escapeHtml(p.name)} â€” ${p.score}%</div>
      <div>${p.isFocus ? '<span class="focus-badge">FOCUS</span>' : '<span class="badge">ACTIVE</span>'}</div>
    </div>
    <div class="progress-bar"><div class="progress" style="width:${p.score}%"></div></div>
    <div class="controls" data-name="${escapeHtml(p.name)}">
      <div class="control-pill control-dec" data-act="-10">-10</div>
      <div class="control-pill control-inc" data-act="+10">+10</div>
      <div class="control-pill control-unfocus" data-act="unfocus">Unfocus</div>
      <div class="control-pill control-pause" data-act="pause">${p.status === 'paused' ? 'Active' : 'Pause'}</div>
      <div class="control-pill control-delete danger" data-act="delete">Delete</div>
      <label class="control-pill" style="display:inline-flex;align-items:center;gap:6px;cursor:pointer;background:var(--btn-bg)">
        ðŸ“· Attach <input type="file" accept="image/*" style="display:none" class="attach-input" />
      </label>
    </div>
    <div class="prediction">Prediction: <span class="predVal">${p.prediction || 'â€”'}</span></div>
    <div class="thumbs"></div>
  `;
  // attach event listeners
  const controls = card.querySelector('.controls');
  controls.addEventListener('click', controlHandler);
  // file input handling
  const fileInput = card.querySelector('.attach-input');
  fileInput.addEventListener('change', (ev)=>handleAttach(ev, p));
  // thumbs
  const thumbs = card.querySelector('.thumbs');
  thumbs.innerHTML = '';
  if(p.images && p.images.length){
    p.images.forEach((dURL, idx)=>{
      const img = document.createElement('img');
      img.src = dURL;
      img.className = 'thumb';
      img.title = 'Tap to OCR';
      img.style.cursor='pointer';
      img.onclick = ()=>runOCRImage(dURL, p);
      thumbs.appendChild(img);
    });
  }
  return card;
}

/* ---------- Event handlers ---------- */
function controlHandler(e){
  const pill = e.target.closest('.control-pill, label.control-pill');
  if(!pill) return;
  const parent = pill.closest('.controls');
  const name = parent.dataset.name;
  const person = findPerson(name);
  const act = pill.dataset.act;
  if(!person) return;
  if(act === '-10' || act === '+10'){
    const delta = act === '-10' ? -10 : 10;
    person.score = clamp(person.score + delta);
    person.updated = now();
    saveData();
    maybeAutoFocus(person);
    render();
    return;
  }
  if(act === 'unfocus'){
    person.isFocus = false;
    person.updated = now();
    saveData();
    render();
    return;
  }
  if(act === 'pause'){
    person.status = (person.status === 'paused') ? 'active' : 'paused';
    person.updated = now();
    saveData();
    render();
    return;
  }
  if(act === 'delete'){
    if(confirm(`Delete ${person.name}?`)){
      data.people = data.people.filter(p => p.name.toLowerCase() !== person.name.toLowerCase());
      saveData();
      render();
    }
    return;
  }
}

/* ---------- Add / Update ---------- */
function addOrUpdatePerson(){
  const name = (nameInput.value || '').trim();
  if(!name){ showAlert('Please enter a name', 2000); return; }
  let person = findPerson(name);
  if(!person){
    person = {
      id: Date.now() + '-' + Math.random().toString(36).slice(2,6),
      name,
      score: 0,
      status: 'active',
      isFocus: false,
      images: [],
      prediction: '',
      updated: now()
    };
    data.people.push(person);
    showAlert(`Added ${name}`, 1500);
  } else {
    person.updated = now();
    showAlert(`Updated ${name}`, 1200);
  }
  saveData();
  nameInput.value = '';
  render();
}

/* ---------- Attach & OCR ---------- */
function handleAttach(ev, person){
  const file = ev.target.files && ev.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = ()=> {
    const dataURL = reader.result;
    person.images = person.images || [];
    person.images.unshift(dataURL); // newest first
    person.updated = now();
    // show thumbnail immediately
    saveData();
    render();
    // also try OCR automatically
    runOCRImage(dataURL, person);
  };
  reader.readAsDataURL(file);
  ev.target.value = '';
}

async function runOCRImage(dataURL, person){
  // run Tesseract.js on image and extract text -> generate a simple reply suggestion
  showAlert('Running OCR...', 2000);
  try{
    const worker = Tesseract.createWorker();
    await worker.load();
    await worker.loadLanguage('eng');
    await worker.initialize('eng');
    const { data: { text } } = await worker.recognize(dataURL);
    await worker.terminate();
    const clean = (text || '').trim();
    if(clean){
      person.lastOCR = clean;
      person.prediction = generatePredictionFromText(clean, person);
      person.updated = now();
      saveData();
      render();
      showAlert('OCR done', 1500);
    } else {
      showAlert('OCR found no text', 2000);
    }
  }catch(err){
    console.error(err);
    showAlert('OCR failed (check image quality)', 3000);
  }
}

function generatePredictionFromText(text, person){
  // Very simple heuristics to produce a numeric "prediction" and label
  // This is NOT ML â€” it's rules: more "love" words -> higher score
  const lower = text.toLowerCase();
  let scoreBoost = 0;
  const loveWords = ['love','miss','luv','babe','baby','ily','i love'];
  const positive = ['yes','yep','sure','ok','done','done now','ðŸ˜Š','ðŸ˜„','great'];
  loveWords.forEach(w=>{ if(lower.includes(w)) scoreBoost += 30; });
  positive.forEach(w=>{ if(lower.includes(w)) scoreBoost += 8; });
  if(lower.includes('sorry')) scoreBoost -= 15;
  if(lower.includes('busy')) scoreBoost -= 8;
  // base is current score
  const base = person.score || 0;
  let pred = clamp(base + scoreBoost);
  // label
  let label = 'Possible';
  if(pred >= 120) label = 'Most Likely';
  else if(pred >= 90) label = 'Likely';
  else if(pred >= 60) label = 'Possible';
  else label = 'Unlikely';
  // store label and numeric (we can allow >100 for "prediction number" display)
  person.prediction = `${pred} â€” ${label}`;
  return person.prediction;
}

/* ---------- Helpers ---------- */
function showAlert(msg, ms = 2500){
  alertEl.style.display = 'block';
  alertEl.textContent = msg;
  setTimeout(()=>{ alertEl.style.display = 'none'; }, ms);
}

function clearAll(){
  if(!confirm('Clear all saved people?')) return;
  data = {people:[], lastDecay: now()};
  saveData();
  render();
  showAlert('Cleared',1200);
}

function escapeHtml(str){ return String(str).replace(/[&<>"']/g, s=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[s])); }

/* ---------- startup ---------- */
(function init(){
  // apply decay on load (auto)
  try{ runDecay(false); }catch(e){ console.warn('decay error', e); }
  // ensure no more than focusLimit focused
  enforceFocusLimit();
  render();
})();

</script>
</body>
</html>